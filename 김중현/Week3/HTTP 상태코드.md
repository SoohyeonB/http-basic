# Section 6. HTTP 상태코드
## HTTP 상태코드 소개
> 클라이언트가 보낸 요청의 처리 상태를 응답(response)에서 알려주는 기능
```
1xx(Information): 요청이 수신되어 처리중
2xx(Successful): 요청 정상처리
3xx(Redirection): 요청을 완료하려면 추가 행동 필요
4xx(Client Error): 클라이언트 오류. 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
5xx(Server Error): 서버 오류. 서버가 정상 요청을 처리하지 못함
```
<br>

#### 모르는 상태코드가 반환될 경우
- 클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면 클라이언트는 상위 상태코드로 해석해 처리한다.
- Ex)
  - 299 → 2xx(Successful)
  - 451 → 4xx(Client Error)
  - 599 → 5xx(Server Error) 
- 미래에 새로운 상태코드가 추가되어도 클라이언트를 변경하지 않아도 된다.
<br>
<br>
<br>
<br>

## 2xx - 성공
> 클라이언트의 요청을 성공적으로 처리
```
200 OK
201 Created
202 Accepted
204 No Content
```
### 200 OK
> 요청 성공

<img width="500" alt="스크린샷 2022-07-18 오후 4 34 49" src="https://user-images.githubusercontent.com/80838501/179464234-1a5ff2c6-d6a4-49c8-9a73-8141252b266a.png">

<br>

### 201 Created
> 요청 성공해 새로운 리소스가 생성

<img width="600" alt="스크린샷 2022-07-18 오후 4 35 22" src="https://user-images.githubusercontent.com/80838501/179464439-40167336-df99-4f74-87f2-1ff27b02e487.png">

- 서버가 생성한 URI를 응답의 헤더 필드에 넣어준다.
- 클라이언트가 201 상태코드를 보고 200 시리즈이므로 성공했다고 인식하고, 201이므로 새로운 리소스가 생성됐고 location 헤더가 있을 수 있겠다 생각
<br>

### 202 Accepted
> 요청이 접수되었으나 처리가 완료되지 않았음
- 배치 처리 같은 곳에 사용
- Ex) 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리
<br>

### 204 No Content
> 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없는 경우
- Ex) 웹 문서 편집기에서의 save 버튼
- save 버튼의 결과로 아무 내용이 없어도 되고, 버튼을 눌러도 같은 화면을 유지해야 하는 상황
- 결과 내용이 없어도 204 상태코드만으로 성공이라는 것은 인식 가능
<br>
<br>
<br>
<br>

## 3xx - Redirection
> 요청을 완료하기 위해 유저 에이전트의 추가 조치 필요
```
300 Multiple Choices
301 Moved Permanetly
302 Found
303 See Other
304 Not Modified
307 Temporary redirect
308 Permanent Redirect
```
### Redirection
- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면 Location 위치로 자동 이동한다.
<br>

### Redirection 예제
> 전에 이벤트 페이지를 /event로 만들어 쓰다가 더 이상 쓰지 않고 새로운 이벤트 페이지인 /new-event를 쓰는 경우
1. 기존 링크를 아는 사용자들은 `/event`로 들어오려고 한다.
2. 서버가 `/event`는 더 이상 쓰지 않는다는 것을 **301** 상태코드를 통해 클라이언트에 알린다. <br> 
   이때, Location 헤더에 새로운 페이지인 `/new-event`를 넣어 전달한다.
3. Location 경로로 자동 redirect하고, 새로운 경로로 서버에 다시 요청한다.
4. 서버는 응답 HTML을 클라이언트에 내려준다. 
<br>

### Redirection의 종류
- 영구 리다이렉션: 특정 리소스의 URI가 영구적으로 이동
  - Ex) /members → /users
- 일시 리다이렉션: 일시적인 변경
  - 주문 완료 후 주문 내역 화면으로 일시적으로 이동
  - PRG: Post/Redirect/Get
- 특수 리다이렉션
  - 결과 대신 캐시를 사용해도 된다.
<br>
<br>

### 영구 리다이렉션
> 301, 308
- 리소스의 URI가 영구적으로 이동했다는 것을 의미
- 원래의 URI를 사용하면 안되며, 검색 엔진 등에서도 변경을 인지할 수 있다.
1) 301 - Moved Permanently
<img width="600" alt="스크린샷 2022-07-18 오후 5 07 40" src="https://user-images.githubusercontent.com/80838501/179469780-caba795d-9551-4feb-8e4c-cc023f67c528.png">

- 리다이렉트 시, 요청 메소드가 **GET**으로 바뀌고, 본문이 제거될 수 있다.(MAY)(브라우저들이 거의 이렇게 구현되어 있다.)
- POST를 원했는데 `/new-event`에 대한 GET 요청으로 바뀌고 본문이 제거되며 새로운 이벤트 페이지가 떠서, 등록하려던 것을 처음부터 다시 입력해야 한다.
<br>
<br>

2) 308 - Permanent Redirect
<img width="600" alt="스크린샷 2022-07-18 오후 5 08 17" src="https://user-images.githubusercontent.com/80838501/179470340-c29d4235-46bb-4557-9017-6e23c790ac97.png">

- 301과 기능은 같다.
- 리다이렉트 시, 요청 메소드와 본문을 **유지**한다.(처음 POST를 보내면 리다이렉트도 POST)
- 실무에서 거의 사용하지 않는다. `/event`에서 `/new-event`로 페이지가 바뀌면 내부적으로 전달해야 할 데이터도 다 바뀌어버리기 때문이다.
<br>
<br>
<br>
<br>

### 일시적인 리다이렉션
> 302, 307, 303
- 리소스의 URI가 일시적으로 변경되므로, 검색 엔진 등에서 URL을 변경하면 안된다.
1) 302 - Found
- 리다이렉트 시 요청 메소드가 GET으로 바뀌고, 본문이 제거될 수 있다.**(MAY)**
<br>

2) 307 - Temporary Redirect
- 302와 기능 동일
- 리다이렉트 시 요청 메소드와 본문을 유지한다.**(MUST NOT)**
<br>

3) 303 - See Other
- 302와 기능 동일
- 리다이렉트 시 요청 메소드가 GET으로 변경된다.
- 302는 GET으로 바뀔 수도 있고 안바뀔 수도 있지만(거의 변경되긴 함), 303은 확실히 GET으로 변경된다.
<br>
<br>

### 일시적인 리다이렉션 예시) PRG: Post/Redirect/Get
- POST로 주문 요청 후에 웹 브라우저를 새로고침(직전 요청을 재요청)하면 중복 주문이 되는 상황이 발생할 수 있다.
#### PRG 사용 전
<img width="600" alt="스크린샷 2022-07-18 오후 5 30 23" src="https://user-images.githubusercontent.com/80838501/179473344-7798fa8a-0a33-4bc5-8596-e380e013df5b.png">

- POST 요청에 대한 서버의 응답에서 상태코드가 `200 OK`
- 주문 후 결과 화면에서 새로고침 수행 시, 마지막 요청인 POST(주문)를 한 번 더 요청한다. 즉, 중복 주문이 발생한다.
<br>

#### PRG 사용
```
POST로 주문 후에 새로 고침으로 인한 중복 주문을 방지하기 위해, 주문 후에 주문 결과 화면을 GET 메소드로 리다이렉트
→ 새로고침해도 결과 화면을 GET으로 조회해 중복 주문 대신 결과 화면만 다시 조회된다.
```
<img width="600" alt="스크린샷 2022-07-18 오후 5 36 58" src="https://user-images.githubusercontent.com/80838501/179474364-b438b1e8-b975-4cf4-871b-ed3bde1c6793.png">

- POST 요청에 대한 서버의 응답에서 상태코드 `302 Found`
- URL이 이미 POST → GET으로 리다이렉트되었기 때문에, 새로고침해도 GET으로 결과화면만 조회된다.
<br>
<br>

#### 역사
- 처음 302 스펙의 의도는 HTTP 메소드를 유지하는 것이었는데, 웹 브라우저들이 대부분 GET으로 변경해버리게 됐다. <br>
→ 모호한 302(MAY) 대신 명확한 307, 303이 등장
<br>

#### 현실
- 307, 303을 권장하긴 하지만, 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하고 있다.
- 자동 리다이렉션 시에 GET으로 바뀌어도 되면, 302를 사용해도 큰 문제는 없다.
<br>
<br>
<br>

### 기타 리다이렉션
> 300, 304
- 300 - Multiple Choices: 잘 안쓴다.
- 304 - Not Modified
  - 캐시를 목적으로 사용
  - 클라이언트에게 리소스가 수정되지 않았음을 알려주어서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트)
  - 304 응답은 로컬 캐시를 사용해야 하기 때문에 응답에 메시지 바디를 포함하면 안된다.
  - 조건부 GET, HEAD 요청 시에 사용
<br>
<br>
<br>
<br>

## 4xx - 클라이언트 오류, 5xx - 서버 오류
### 4xx (Client Error)
- 클라이언트의 요청에 잘못된 문법 등으로 인해 서버가 요청을 수행할 수 없다.
- 오류의 원인이 클라이언트에 있기 때문에, 동일한 시도를 다시 해도 실패한다.
- 4xx 오류는 요청 자체를 수정하지 않는 이상 재요청해도 실패하고, 5xx 오류는 서버의 문제가 해결되면 동일한 요청을 다시 했을 때 성공할 가능성이 있다.
<br>
<br>

### 400 Bad Request
> 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없다.
- 요청 구문, 메시지 등 오류
- 클라이언트는 요청 내용을 다시 검토해 보내야 한다.
- Ex) 요청 파라미터가 잘못되는 경우, API 스펙이 맞지 않는 경우
<br>
<br>

### 401 Unauthorized
> 클라이언트가 해당 리소스에 대한 인증이 필요하다.
- 인증(Authentication)되지 않는 경우에 발생
- 401 오류 발생 시, 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명해준다.
- 참고)
  - 인증(Authentication): 본인이 누구인지 확인(로그인)
  - 인가(Authorization): 권한 부여(ADMIN 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있는 것)
  - 오류 메시지명이 Unauthorized이지만, 인증되지 않음
<br>
<br>

### 403 Forbidden
> 서버가 요청을 이해했지만 승인을 거부
- 주로 인증 자격 증명은 있지만 접근 권한이 불충분한 경우
- Ex) ADMIN 등급이 아닌 사용자가 로그인은 했지만(인증 자격 O), ADMIN 등급의 리소스에 접근하는 경우
<br>
<br>

### 404 Not Found
> 요청 리소스를 찾을 수 없음
- 요청 리소스가 서버에 없는 경우
- 클라이언트가 권한이 부족한 리소스에 접근하는 경우 해당 리소스를 숨기고 싶을 때 403 대신 404 코드 
<br>
<br>
<br>

### 5xx (Server Error)
> 서버 오류
- 서버 문제로 오류 발생
- 서버에 문제가 있는 것이기 때문에 서버 문제가 해결되면 재시도해서 성공할 수도 있다.
<br>
<br>

### 500 Internal Server Error
> 서버 문제로 오류 발생, 애매하면 500 오류
- 서버 내부 문제로 오류 발생하는 경우
- 애매하면 500 오류를 띄운다.
<br>
<br>

### 503 Service Unavailable
> 서비스 이용 불가
- 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없는 경우
- Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있다.
